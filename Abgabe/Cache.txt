Zwischenspeicher für Personen
Wenn wir von der Kinect in einem Frame kein gültiges Skelett erhalten, entfernen wir die Person aus der Liste der aktiven Personen im Device. Vielleicht wurde jedoch die Person nur kurz verdeckt. Deshalb löschen wir sie nicht direkt, sondern lagen sie nit einem Timestamp in einen Cache. Wenn wir jetzt eine neue Person erhalten würden, schauen wir zuerst, ob eine Person aus dem Cache dazu passen würde. Falls das Skelett im Umkreis von 0.5m(kongigurierbar über eine Konstante) um eine Person aus dem Cache liegt, wird es dieser zugeteilt.
Nach 5 Sekunden (ebenfalls konfigurierbar) werden die Personen im Cache automatisch entfernt. Ein längeres Speichern macht keinen Sinn, sondern erhäht die Gefahr, dass User unabsichtlich Personen hijacken.

Konstanten
Unser Framework enthält einige Konstanten, um die Erkennung und das User-Experience an Kundenwünsche anzupassen.
Allgemeine Konstanten:
EPSILON: Genauigkeit eines Floating-Point-Wertes für die Identität
Im Device:
CacheMercyTime: Zeit, die eine Person im Cache zwischengespeichert wird.
MinMatchDistance: Abstand der zur Person in Cache vorhanden sein muss, damit der Match gültig ist.
AccelerationDiff: Maximale Änderung der Werte des Beschleunigungssensors, damit das Skelett noch verarbeitet wird.
In Person:
SkeletonsToStore: Anzahl der Skelette, die von der Person gespeichert werden, als History. Diese sollte > 10 sein, wenn grosse Mediane im Spiel sind noch grösser. Wir halten es aber aus Performancegründen nicht Sinnvoll, bei jedem Frame zu weit in der History zurückzugehen.
In SkeletonMath:
Tolerance: Minimaldistanz in Meter, die zurückgelegt werden muss, dass noch eine Richtung erkannt wird.
MedianTolerance: Das selbe, jedoch mit Median-Auswertung
MedianCorrectNeeded: Wie häufig muss die Bewegungsrichtung gestimmt haben, dass die Richtung als gültig erkannt wird.
In Conditions oder Gesture Checkers:
ConditionTimeout: Zeit, während der die Geste abwartet, ob sie vielleicht noch komplettiert wird. In Millisekunden.
Andere sind individuell und selbsterklärend.

Ausblick
Eigenschaften, die beachtet werden sollten bei einer Weiterführung unserer Arbeit:
Gui
Unser Gui ist nur ein Prototyp. Falls es weiterentwickelt werden soll, muss ein Error-Handeling eingeführt werden und die Asynchronität verbessert werden. Wir würden aber nicht empfehlen, unser Gui weiterzuverwenden.
Wenn ein neues Gui entwickelt wird, gibt es zusätzlich zu den üblichen Anforderungen an ein Gui noch zusätzliche Anforderungen: 
Die grafischen Elemente müssen gross sein, dass man diese auch aus der Entfernung erkennt.
Es darf nur wenig interaktive Elemente auf einer Seite haben, dass für den Benutzer immer klar ersichtlich ist, was welche Aktion beschreibt
Alle möglichen Aktionen auf der Seite sollten klar markiert sein.
Die möglichen Gesten sollten nicht textuell beschrieben werden, da das sonst zu Missverständnissen kommen kann. Es ist für den Benutzer viel verständlicher, wenn man ihm eine kleine Animation in Form eines Strichmännchen zeigt.
Falls die Bedienzone (Fläche, von wo aus Bedient wird), nicht klar definiert ist, wäre es hilfreich, den Nutzer zu warnen, wenn er nahe am Rand der Bedienzone steht, wo er danach nicht mehr erfasst wird. Das zieht jedoch Änderungen am Framework nach sich.

Filter-methoden
Wir haben werschieden Methoden zur Filterung evaluiert. Wir wenden die Filter jeweils erst auf das Endresultat (Geschwindigkeit/Distanz) an. So können wir Ausreisser von einzelnen Achswerten besser ausgleichen.
Bildet man den Mittelwert aus verschiedenen Werten gebildet. Dadurch werden jedoch Ausreisser überbewertet.
Mit dem Median ignorieren wir einzelne Ausreisser, jedoch erhalten wir manche Werte doppelt.
Durch eine Voraussage des nächsten Punkts kann man Ausreisser ignorieren, jedoch hat mman bei Richtungsänderungen der Bewegungen eine Verzögerung, bis diese detektiert wird. Aufwändiger in der Implementierung.
Wir haben uns für den Median entschieden, da er Ausreisser gut filtert und es für uns kein Problem darstellt, wenn wir die gleichen Werte mehrfach erhalten.

Framework
Die aktuellen Gesten wurden noch keinem Usertest unterzogen, was die Qualität der Gesten stark verbessern könnte. Auch andere Konstanten sollte noch durch Usertests verbessert werden.
Bei den Gesten sollten zusätzlich noch die Zusatzbedingungen verfeinert werden, was die Erkennung verbessern würde. Das sind keine aufwändigen Arbeiten, aber es braucht einige Tests mit Benutzern um die Probleme zu erkennen.
Um allfälige Änderungen am Code zu testen kann man unser Mock-Device verwenden.
Falls man viele Tests ausführt, würde es sich anbieten, einen weiteren Abstraktionslayer zum KinectSensor einzuführen damit man Mocking-Tests dürchführen kann, ohne den Code zu ändern.
Eine Erweiterung des Mock-Devices, sodass man bestimmte Skelettdaten erzeugen kann, würde ermöglichen, Gesten automatisiert zu testen. Das wäre aber ein grosser Aufwand.

Untersuchungen
Wenn man die Usability verbessern will, sollte man unsere Konkurenzanalyse noch vertiefen. Es gibt relativ viel kleine Projekte und Analysen zu diesem Thema, die wir aus Zeitgründen nicht auswerten konnten.
Eine andere Möglichkeit, die Usability zu verbessern sind Usertests. Mit unserem Framewok lassen sich einfach neue Gesten erstellen, die dann anhand vom Feedback der Nutzer verfeinert oder verworfen werden können.